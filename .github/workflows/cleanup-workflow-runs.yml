name: Cleanup Old Workflow Runs

on:
  schedule:
    - cron: '0 0 * * 0' # Weekly
  workflow_dispatch:
    inputs:
      days_to_keep:
        description: 'Days to keep (0 = delete EVERYTHING including today)'
        required: true
        default: '0'

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    
    steps:
      - name: Delete old workflow runs
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          DAYS_TO_KEEP: ${{ github.event.inputs.days_to_keep || 0 }}
        run: |
          # 1. Smart Date Calculation
          if [[ "$DAYS_TO_KEEP" -eq 0 ]]; then
            # If 0, set cutoff to TOMORROW to include all of today's runs
            CUTOFF_DATE=$(date -d "+1 day" +%Y-%m-%d)
            echo "üî• DELETION MODE: Deleting EVERYTHING created before $CUTOFF_DATE (includes today)"
          else
            # Otherwise, use standard logic (e.g., older than 3 days)
            CUTOFF_DATE=$(date -d "-$DAYS_TO_KEEP days" +%Y-%m-%d)
            echo "üìÖ Standard Cleanup: Deleting runs older than $CUTOFF_DATE"
          fi

          echo "---------------------------------------------------"

          # 2. Get All Workflow Names Dynamically
          # This ensures we catch 'pages-build-deployment', 'Code Quality Checks', etc.
          # without hardcoding them.
          WORKFLOW_NAMES=$(gh workflow list --all --json name --jq '.[].name')

          # Loop through every workflow found in the repo
          echo "$WORKFLOW_NAMES" | while read -r workflow; do
            if [ -z "$workflow" ]; then continue; fi
            
            echo "üîç Checking workflow: '$workflow'..."
            
            # Fetch run IDs
            RUNS=$(gh run list \
              --workflow "$workflow" \
              --created "<$CUTOFF_DATE" \
              --json databaseId \
              --limit 100 \
              --jq '.[].databaseId')
            
            if [ -z "$RUNS" ]; then
              echo "   ‚úÖ No deletable runs found."
            else
              COUNT=$(echo "$RUNS" | wc -w)
              echo "   üóëÔ∏è Found $COUNT runs to delete."
              
              for run_id in $RUNS; do
                # Run deletion in background for speed, then wait
                gh run delete "$run_id" >/dev/null 2>&1 || echo "   ‚ö†Ô∏è Failed to delete $run_id" &
              done
              wait # Wait for batch to finish
              echo "   ‚ú® Batch cleaned."
            fi
            echo "---------------------------------------------------"
          done
          
          echo "üéâ Complete cleanup finished."
