name: Cleanup Workflow Runs

on:
  workflow_dispatch:
    inputs:
      clear_app_version_updates:
        description: "Clear 'App Version Updates'"
        type: boolean
        default: true
      
      clear_bulk_updates:
        description: "Clear 'Bulk IPA Updates'"
        type: boolean
        default: true
      
      clear_pages:
        description: "Clear 'pages-build-deployment'"
        type: boolean
        default: true

      retain_latest:
        description: "Keep the latest run for each?"
        type: boolean
        default: true

permissions:
  actions: write
  contents: read

jobs:
  delete-runs:
    name: "Delete Old Workflow Runs"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: "Delete Workflow Runs"
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CLEAR_APP: ${{ github.event.inputs.clear_app_version_updates }}
          CLEAR_BULK: ${{ github.event.inputs.clear_bulk_updates }}
          CLEAR_PAGES: ${{ github.event.inputs.clear_pages }}
          RETAIN_LATEST: ${{ github.event.inputs.retain_latest }}
        run: |
          # Disable exit on error to allow the script to continue even if one batch fails
          set +e

          delete_runs() {
            local workflow_name="$1"
            local toggle="$2"
            
            if [[ "$toggle" != "true" ]]; then
              echo "‚è≠Ô∏è Skipping '$workflow_name'"
              return
            fi
            
            echo "üîç Processing '$workflow_name'..."
            
            # Loop to handle pagination and deletion
            local loop_count=0
            local max_loops=100
            
            while [ $loop_count -lt $max_loops ]; do
              # Fetch runs (completed/failed only) to avoid killing active jobs
              # Sorting is implied (newest first)
              RUNS=$(gh run list --workflow "$workflow_name" --limit 50 --json databaseId,status --status completed,cancelled,failure,skipped,timed_out || true)
              
              if [[ -z "$RUNS" ]] || [[ $(echo "$RUNS" | jq length) -eq 0 ]]; then
                echo "‚úÖ No cleanable runs found for '$workflow_name'."
                break
              fi
              
              # Logic to preserve the latest run
              if [[ "$RETAIN_LATEST" == "true" ]]; then
                COUNT=$(echo "$RUNS" | jq length)
                
                # If only 1 run exists and we want to keep it, stop.
                if [[ "$COUNT" -eq 1 ]]; then
                   echo "üõ°Ô∏è Latest run preserved. Cleanup complete."
                   break
                fi
                
                # Exclude the first one (index 0) from the deletion list
                IDS=$(echo "$RUNS" | jq -r '.[1:] | .[].databaseId')
              else
                # Delete all
                IDS=$(echo "$RUNS" | jq -r '.[].databaseId')
              fi
              
              # Check if we have IDs to delete
              if [[ -z "$IDS" ]]; then
                 echo "‚ú® No runs to delete in this batch."
                 break
              fi
              
              # Calculate count for logging
              BATCH_COUNT=$(echo "$IDS" | wc -w)
              echo "   üóëÔ∏è Deleting batch of $BATCH_COUNT runs..."
              
              # Batch delete: Pass 20 IDs at a time to 'gh run delete'
              # This is much faster/safer than spawning 20 separate processes
              echo "$IDS" | xargs -n 20 gh run delete 
              
              ((loop_count++))
              # Tiny sleep to be nice to the API
              sleep 1
            done
            
            if [ $loop_count -eq $max_loops ]; then
              echo "‚ö†Ô∏è Hit max loop limit. Run again if needed."
            fi
            echo "----------------------------------------"
          }
          
          echo "üßπ Starting Cleanup..."
          echo "----------------------------------------"
          
          delete_runs "App Version Updates" "$CLEAR_APP"
          delete_runs "Bulk IPA Updates - Tweaked Apps" "$CLEAR_BULK"
          delete_runs "pages-build-deployment" "$CLEAR_PAGES"
          
          echo "üéâ Cleanup finished."