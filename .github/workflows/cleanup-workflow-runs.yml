name: Cleanup Workflow Runs

on:
  workflow_dispatch:
    inputs:
      clear_app_version_updates:
        description: "Clear 'App Version Updates'"
        type: boolean
        default: true
      
      clear_bulk_updates:
        description: "Clear 'Bulk IPA Updates'"
        type: boolean
        default: true
      
      clear_pages:
        description: "Clear 'pages-build-deployment'"
        type: boolean
        default: true

      retain_latest:
        description: "Keep the latest run for each?"
        type: boolean
        default: true

permissions:
  actions: write
  contents: read

jobs:
  delete-runs:
    name: "Delete Old Workflow Runs"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: "Delete Workflow Runs"
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CLEAR_APP: ${{ github.event.inputs.clear_app_version_updates }}
          CLEAR_BULK: ${{ github.event.inputs.clear_bulk_updates }}
          CLEAR_PAGES: ${{ github.event.inputs.clear_pages }}
          RETAIN_LATEST: ${{ github.event.inputs.retain_latest }}
        run: |
          set +e # Don't exit on error so we can see logs

          delete_runs() {
            local workflow_file="$1"
            local toggle="$2"
            local pretty_name="$3"
            
            if [[ "$toggle" != "true" ]]; then
              echo "‚è≠Ô∏è Skipping '$pretty_name' ($workflow_file)"
              return
            fi
            
            echo "üîç Processing '$pretty_name'..."
            
            local loop_count=0
            local max_loops=50
            
            while [ $loop_count -lt $max_loops ]; do
              echo "   Fetching runs for $workflow_file..."
              
              # Use filename matching explicitly
              RUNS=$(gh run list --workflow "$workflow_file" --limit 30 --json databaseId,status --status completed,cancelled,failure,skipped,timed_out 2>/dev/null)
              
              if [[ -z "$RUNS" ]] || [[ $(echo "$RUNS" | jq length) -eq 0 ]]; then
                echo "   ‚úÖ No cleanable runs found."
                break
              fi
              
              if [[ "$RETAIN_LATEST" == "true" ]]; then
                COUNT=$(echo "$RUNS" | jq length)
                if [[ "$COUNT" -eq 1 ]]; then
                   echo "   üõ°Ô∏è Latest run preserved."
                   break
                fi
                IDS=$(echo "$RUNS" | jq -r '.[1:] | .[].databaseId')
              else
                IDS=$(echo "$RUNS" | jq -r '.[].databaseId')
              fi
              
              if [[ -z "$IDS" ]]; then
                 echo "   ‚ú® No runs to delete in this batch."
                 break
              fi
              
              BATCH_COUNT=$(echo "$IDS" | wc -w)
              echo "   üóëÔ∏è Deleting batch of $BATCH_COUNT runs..."
              echo "$IDS" | xargs -n 20 gh run delete 
              
              ((loop_count++))
              sleep 2
            done
            echo "----------------------------------------"
          }
          
          echo "üßπ Starting Cleanup..."
          echo "----------------------------------------"
          
          # Use EXACT FILENAMES here
          delete_runs "app-version-updates.yml" "$CLEAR_APP" "App Version Updates"
          delete_runs "bulk-tweaked-apps-updates.yml" "$CLEAR_BULK" "Bulk IPA Updates"
          delete_runs "pages-build-deployment" "$CLEAR_PAGES" "Pages Deployment"
          
          echo "üéâ Cleanup finished."