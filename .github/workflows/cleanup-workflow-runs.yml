name: Cleanup Workflow Runs

on:
  workflow_dispatch:
    inputs:
      clear_app_version_updates:
        description: "Clear 'App Version Updates'"
        type: boolean
        default: true
      
      clear_bulk_updates:
        description: "Clear 'Bulk IPA Updates'"
        type: boolean
        default: true
      
      clear_pages:
        description: "Clear 'pages-build-deployment'"
        type: boolean
        default: true

      retain_latest:
        description: "Keep the latest run for each?"
        type: boolean
        default: true

permissions:
  actions: write
  contents: read

jobs:
  delete-runs:
    name: "Delete Old Workflow Runs"
    runs-on: ubuntu-latest
    timeout-minutes: 360 # Increased to 6 hours for large history
    
    steps:
      - name: "Delete Workflow Runs"
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CLEAR_APP: ${{ github.event.inputs.clear_app_version_updates }}
          CLEAR_BULK: ${{ github.event.inputs.clear_bulk_updates }}
          CLEAR_PAGES: ${{ github.event.inputs.clear_pages }}
          RETAIN_LATEST: ${{ github.event.inputs.retain_latest }}
        run: |
          set -e

          delete_runs() {
            local workflow_name="$1"
            local toggle="$2"
            
            if [[ "$toggle" != "true" ]]; then
              echo "‚è≠Ô∏è Skipping '$workflow_name'"
              return
            fi
            
            echo "üîç Processing '$workflow_name'..."
            
            # Counter to prevent infinite loops if API fails
            local loop_count=0
            local max_loops=1000
            
            while [ $loop_count -lt $max_loops ]; do
              # 1. Fetch runs (Limit 1000)
              echo "   [Loop $loop_count] Fetching run list..."
              RUNS=$(gh run list --workflow "$workflow_name" --limit 1000 --json databaseId,status || true)
              
              if [[ -z "$RUNS" ]] || [[ $(echo "$RUNS" | jq length) -eq 0 ]]; then
                echo "‚úÖ No (more) runs found for '$workflow_name'."
                break
              fi
              
              # 2. Extract IDs
              if [[ "$RETAIN_LATEST" == "true" ]]; then
                # Keep index 0 (latest)
                IDS=$(echo "$RUNS" | jq -r '.[1:] | .[].databaseId')
                # If IDs is empty here, we only have 1 run left (the one to keep)
                if [[ -z "$IDS" ]]; then
                  echo "üõ°Ô∏è Latest run preserved. Cleanup complete."
                  break
                fi
              else
                # Delete all
                IDS=$(echo "$RUNS" | jq -r '.[].databaseId')
              fi
              
              COUNT=$(echo "$IDS" | wc -w)
              echo "   üóëÔ∏è Deleting batch of $COUNT runs..."
              
              # 3. Delete Batch
              # -n 30: Smaller batch size per call to ensure stability
              # -P 2:  Reduced parallelism to avoid GitHub Rate Limiting/Throttling
              echo "$IDS" | xargs -n 30 -P 2 gh run delete || true
              
              ((loop_count++))
              
              # Small sleep to be nice to the API
              sleep 2
            done
            
            if [ $loop_count -eq $max_loops ]; then
              echo "‚ö†Ô∏è Hit max loop limit. There may still be runs left."
            fi
            
            echo "----------------------------------------"
          }
          
          echo "üßπ Starting Robust Cleanup..."
          echo "----------------------------------------"
          
          # 1. App Version Updates
          delete_runs "App Version Updates" "$CLEAR_APP"
          
          # 2. Bulk IPA Updates
          delete_runs "Bulk IPA Updates - Tweaked Apps" "$CLEAR_BULK"
          
          # 3. Pages Build and Deployment
          delete_runs "pages-build-deployment" "$CLEAR_PAGES"
          
          echo "üéâ Cleanup finished."
